<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="GoShimmer Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="GoShimmer Blog Atom Feed">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons"><title data-react-helmet="true">Autopeering | GoShimmer</title><meta data-react-helmet="true" property="og:url" content="https://goshimmer.docs.iota.org//docs/protocol_specification/autopeering"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Autopeering | GoShimmer"><meta data-react-helmet="true" name="description" content="In order to establish connections, an IOTA node needs to discover and maintain a list of the reachable IP addresses of other peers. Nodes to be kept up-to-date about the ledger state, thus they exchange information with each other. Each node establishes a communication channel with a small subset of nodes (i.e., neighbors) via a process called peering. Such a process must be resilient against eclipse attacks arbitrary nodes can be created, but it is difficult to produce high mana nodes."><meta data-react-helmet="true" property="og:description" content="In order to establish connections, an IOTA node needs to discover and maintain a list of the reachable IP addresses of other peers. Nodes to be kept up-to-date about the ledger state, thus they exchange information with each other. Each node establishes a communication channel with a small subset of nodes (i.e., neighbors) via a process called peering. Such a process must be resilient against eclipse attacks arbitrary nodes can be created, but it is difficult to produce high mana nodes."><link data-react-helmet="true" rel="shortcut icon" href="/img/logo/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://goshimmer.docs.iota.org//docs/protocol_specification/autopeering"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/autopeering" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/autopeering" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.e8df95d8.css">
<link rel="preload" href="/assets/js/runtime~main.dedbe278.js" as="script">
<link rel="preload" href="/assets/js/main.0e69db9d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/welcome">Documentation</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/welcome">Documentation</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/welcome">Welcome</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/faq">FAQ</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/setup">Set up a node</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">Obtain tokens</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/wallet-library">Wallet library</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/dApp">Write a dApp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/manual_peering">Manual peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/static_identity">Create a static identity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/custom_dRNG">Set up a custom dRNG committee</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/monitoring">Set up the Monitoring Dashboard</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">How to create and send transactions</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Implementation design</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/event_driven_model">Event driven model</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/packages_plugins">Packages and plugins</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/plugin">Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/configuration_parameters">Configuration parameters</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/object_storage">Object storage</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Protocol Specification</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification">Protocol Specification</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/protocol">Protocol High Level Overview</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Components</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/components">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/tangle">Tangle</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/protocol_specification/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/congestion_control">Congestion Control</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/consensus_mechanism">Consensus Mechanism</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/ledgerstate">UTXO and Ledgerstate</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/advanced_outputs">Advanced Outputs (Experimental)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/markers">Markers</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/glossary">Glossary</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">API</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/api">Client Lib</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/webAPI">WebAPI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/info">Node Info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/manual_peering">Manual Peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/communication">Communication Layer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/ledgerstate">Ledgerstate</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/dRNG">dRNG</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/snapshot">Snapshot</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/faucet">Faucet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/spammer">Spammer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/tools">Tools</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tooling</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/docker_private_network">Docker Private Network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/integration_tests">Integration Tests</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Team Resources</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/release">How To Do a Release</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/guidelines">Code Guidelines</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/local_development">Local Development</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/analysis_dashboard">Modify the Analysis Dashboard</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">Autopeering</h1></header><p>In order to establish connections, an IOTA node needs to discover and maintain a list of the reachable IP addresses of other peers. Nodes to be kept up-to-date about the ledger state, thus they exchange information with each other. Each node establishes a communication channel with a small subset of nodes (i.e., neighbors) via a process called <code>peering</code>. Such a process must be resilient against eclipse attacks: if all of a node’s neighbors are controlled by an attacker, then the attacker has complete control over the node’s view of the Tangle. Moreover, to prevent or limitate sybil-based attacks, the neighbor selection protocol makes use of a scarce resource dubbed Consensus Mana: arbitrary nodes can be created, but it is difficult to produce high mana nodes.</p><p>Throughout this section the terms <code>Node</code> and <code>Peer</code> are used interchangeably to refer to a <code>Node</code> device.</p><p>The usage of the <em>Ping</em> and <em>Pong</em> mechanism is to be considered as a bidirectional exchange similarly to how described by other standards such as <a href="https://core-wg.github.io/coap-sig/" target="_blank" rel="noopener noreferrer">CoAP</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2" target="_blank" rel="noopener noreferrer">WebSocket</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="node-identities"></a>Node identities<a class="hash-link" href="#node-identities" title="Direct link to heading">#</a></h2><p>Every node has a cryptographic identity, a key on the ed25519 elliptic curve. The <code>blake2b</code> hash of the public key of the peer serves as its identifier or <code>node ID</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="peer-discovery"></a>Peer Discovery<a class="hash-link" href="#peer-discovery" title="Direct link to heading">#</a></h2><p>The main goal of the <em>Peer Discovery</em> protocol is to expose an interface providing a list of all the verified peers.
To bootstrap the peer discovery, a node <em>must</em> be able to reach one or more entry nodes. To achieve this, the implementation of the protocol <em>shall</em> provide a hard-coded list of trusted <strong>entry nodes</strong> run by the IF or by trusted community members that answer to peer discovery packets coming from new nodes joining the IOTA network. This approach is a common practice of many distributed networks <a href="https://ieeexplore.ieee.org/iel7/9739/8649699/08456488.pdf" target="_blank" rel="noopener noreferrer">[Neudecker 2018]</a>.
Public Key-based Cryptography (PKC) <em>shall</em> be used for uniquely <a href="#Node_identities">identifying</a> peers and for authenticating each packet.
The usage of the Ping and Pong protocols is that <em>Ping</em> are sent to verify a given peer and, upon reception of a valid <em>Pong</em> as a response from that peer, the peer is verified.
Once a peer has been verified, it can be queried to discover new peers by sending a <em>DiscoveryRequest</em>. As a response, a <em>DiscoveryResponse</em> <em>shall</em> be returned, containing a list of new peers. The new peer nodes in this list <em>shall</em> be verified by the receiving application.</p><p>This process is summarized in the following figure and detailed in the following subsections:</p><p><img alt="Peer discovery" src="/assets/images/peer_discovery-693ece6c7a10731425bbb474bea31ccf.png" title="Peer discovery"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="verification"></a>Verification<a class="hash-link" href="#verification" title="Direct link to heading">#</a></h3><p>The verification process aims at both verifying peer identities and checking their online status. Each peer <em>shall</em> maintain a list of all the known peers. This list <em>shall</em> be called <code>known_peer_list</code>. Elements of any known peer list <em>shall</em> contain a reference to a <a href="#Peer">Peer</a> and a time at which it <em>shall</em> be verified/re-verified.
As such, the <code>known_peer_list</code> can be seen as a time-priority queue. A newly discovered peer gets added to the list at the current time. Whenever a peer is verified, its time value on the <code>known_peer_list</code> gets updated to the time at which that peer <em>shall</em> be re-verified.
The intent of this arrangement is to allow the node application to first verify newly discovered (and thus still unverified) peers and then to re-verify older peers (to confirm their online status) by iterating over the <code>known_peer_list</code>.
It is worthwhile to note that the order in which the <code>known_peer_list</code> is worked through is important. For example, if the peer is added to the front (&#x27;head&#x27;) of the <code>known_peer_list</code>, it is possible for an adversary to front-fill the <code>known_peer_list</code> with a selection of its own nodes. This is resolved by the use of the time-priority queue.</p><p>The verification process always initiates from a <em>Ping</em>. Upon reception of a <em>Ping</em>, a peer <em>shall</em> check its validity by:</p><ul><li>verifying that the signature of the <em>Ping</em> is valid and discarding the request otherwise;</li><li>checking that the <code>version</code> and <code>network_id</code> fields match its configuration and discarding the <em>Ping</em> otherwise;</li><li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the packet otherwise;</li><li>checking that the <code>dest_addr</code> matches its IP address and discarding the <em>Ping</em> otherwise.</li></ul><p>Upon successful validation of a received <em>Ping</em>, a peer <em>shall</em> respond with a <em>Pong</em>. In case the sender of the <em>Ping</em> is a new peer from the perspective of the receiving node, the receiver peer <em>shall</em> add it to its <code>known_peer_list</code>. This enables the verification process to also occur in the reverse direction. </p><p>Upon reception of a <em>Pong</em>, a peer <em>shall</em> check its validity by:</p><ul><li>verifying that the signature of the <em>Pong</em> is valid and discarding it otherwise;</li><li>checking that the <code>req_hash</code> field matches a request (i.e. <em>Ping</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>Ping</em> and <em>Pong</em> is not greater than a given threshold) and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise;</li><li>checking that the <code>dest_addr</code> matches its IP address and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise.</li></ul><p>Upon successful validation of a received <em>Pong</em>, a peer <em>shall</em>:</p><ul><li>add the peer sender of the <em>Pong</em> to a list of verified peers called <code>verified_peer_list</code>;</li><li>move the peer entry of the <code>known_peer_list</code> to the tail.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="removal"></a>Removal<a class="hash-link" href="#removal" title="Direct link to heading">#</a></h3><p>While verifying a new peer, if no or an invalid <em>Pong</em> is received after <code>max_verify_attempts</code> attempts, that node <em>shall</em> be removed from the <code>known_peer_list</code>. Each expected reply should have a timeout such that if no answer is received after that, an attempt is considered concluded and counted as failed. </p><p>Each peer on the <code>verified_peer_list</code> <em>shall</em> be re-verified after <code>verification_lifetime</code> hours; while re-verifying a peer, if no or invalid <em>Pong</em> is received after <code>max_reverify_attempts</code> attempts, the peer <em>shall</em> be removed from the <code>verified_peer_list</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="discovery"></a>Discovery<a class="hash-link" href="#discovery" title="Direct link to heading">#</a></h3><p>Each peer entry of the <code>verified_peer_list</code> may be used to discover new peers. This process is initiated by sending a <em>DiscoveryRequest</em>.</p><p>Upon reception of a <em>DiscoveryRequest</em>, a peer node <em>shall</em> check its validity by:</p><ul><li>checking that the sender of the <em>DiscoveryRequest</em> is a verified peer (i.e. is stored in the <code>verified_peer_list</code>) and discarding the request otherwise;</li><li>verifying that the signature of the <em>DiscoveryRequest</em> is valid and discarding the request otherwise;</li><li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the request otherwise.</li></ul><p>Upon successful validation of a received <em>DiscoveryRequest</em>, a peer <em>shall</em> reply with a <em>DiscoveryResponse</em>.</p><p>Upon reception of a <em>DiscoveryResponse</em>, a peer <em>shall</em> check its validity by:</p><ul><li>verifying that the signature of the <em>DiscoveryResponse</em> is valid and discarding the response otherwise;</li><li>checking that the <code>req_hash</code> field matches a discovery request (i.e. <em>DiscoveryRequest</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>DiscoveryRequest</em> and <em>DiscoveryResponse</em> is not greater than a given threshold) and discarding the response otherwise.</li></ul><p>Upon successful validation of a received <em>DiscoveryResponse</em>, a node <em>shall</em> add the nodes contained in the <code>peers</code> field to the <code>known_peer_list</code>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="neighbor-selection"></a>Neighbor Selection<a class="hash-link" href="#neighbor-selection" title="Direct link to heading">#</a></h2><p>The goal of the neighbor selection is to build a node&#x27;s neighborhood (to be used by the gossip protocol) while preventing attackers from “tricking” other nodes into becoming neighbors. Neighbors are established when one node sends a peering request to another node, which in turn accepts or rejects the request with a peering response. </p><p>To prevent attacks, the protocol makes the peering request <em>verifiably random</em> such that attackers cannot create nodes to which the target node will send requests. At its core, the neighbor selection protocol uses both a screening process called <em>Consensus Mana rank</em> and a <em>score function</em> that takes into account some randomness dubbed <em>private salt</em> and <em>public salt</em>.
Half of the neighbors will be constituted from nodes that accepted the peering request, while half will be constituted of nodes that will request for the peering. The two distinct groups of neighbors are consequently called:</p><ul><li>Chosen neighbors (outbound). The peers that the node proactively selected through the neighbor selection mechanism.</li><li>Accepted neighbors (inbound). The peers that sent the peering request to the node and were accepted as a neighbor.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="local-variables"></a>Local variables<a class="hash-link" href="#local-variables" title="Direct link to heading">#</a></h3><p>Local variables defined here are included to help in understanding the protocol described in this section. The node application shall handle those variables in some form.</p><ul><li><code>saltUpdateInterval</code>: The time interval at which nodes shall update their salts.</li><li><code>responseTimeout</code>: The time that node waits for a response during one peering attempt.</li><li><code>requestExpirationTime</code>: The time used for the request timestamp validation, if the timestamp is older than this threshold the request is dropped</li><li><code>maxPeeringAttempts</code>: The maximum number of peering requests retries sent to the selected node before the next salt update.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="mana-rank-interval"></a>Mana rank interval<a class="hash-link" href="#mana-rank-interval" title="Direct link to heading">#</a></h3><p>Each peer discovered and verified via the <em>Peer Discovery</em> protocol <em>shall</em> have a consensus mana value associated with it. The peer running the <em>Neighbor Selection</em> protocol <em>shall</em> keep this information up-to-date and use it to update a data structure called <code>manaRank</code> containing the list of the nodes&#x27; identities for each mana value. The aim of this ranking is to select a subset of peers having similar mana to the node preparing the ranking. More specifically, let&#x27;s define <code>potentialNeighbors</code> to be such a subset, that is divided into a <code>lower</code> and an <code>upper</code> set with respect to a <code>targetMana</code> value (i.e., the mana value of the node performing the ranking). By iterating over the <code>manaRank</code>, each node <em>shall</em> fill both the <code>lower</code> and  <code>upper</code> sets with nodes&#x27; identities having a similar rank to itself, not less/greater than a given threshold <code>rho</code> respectively, except when each subset does not reach the minimal size <code>r</code>.</p><p>The following pseudocode describes a reference implementation of this process:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Inputs: </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    manaRank: mapping between mana values and the list of nodes&#x27; identities with that mana; </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    targetMana: the mana value of the node performing the ranking;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    rho: the ratio determining the length of the rank to consider;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    r: the minimum number of nodes&#x27; identities to return for both lower and upper sets;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Largest(r, targetMana): the set of r largest cMana holders less than targetMana;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Smallest(r, targetMana): the set of r smallest cMana holders greater than targetMana;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Outputs:</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    potentialNeighbors: the set of nodes&#x27; identities to consider for neighbor selection;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly vbnet"><pre tabindex="0" class="prism-code language-vbnet codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">FOR mana IN manaRank</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nodeID = manaRank[mana]</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    IF mana &gt; targetMana</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        IF mana / targetMana &lt; rho</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            Append(upperSet, nodeID)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ELSE IF mana == 0 || mana == targetMana</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        BREAK</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ELSE IF targetMana / mana &lt; rho</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Append(lowerSet, nodeID)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">IF Len(lowerSet) &lt; r</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // set lowerSet with the r largest mana holders less than targetMana</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    lowerSet = Largest(r, targetMana)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">IF Len(upperSet) &lt; r</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // set upperSet with the r smallest mana holders greater than targetMana</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    upperSet = Smallest(r, targetMana)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">potentialNeighbors = Append(upperSet, lowerSet)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">RETURN potentialNeighbors</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="selection"></a>Selection<a class="hash-link" href="#selection" title="Direct link to heading">#</a></h3><p>The maximum number of neighbors is a parameter of the gossip protocol. This section proposes to use a size of 8 equally divided into 4 chosen (outbound) and 4 accepted (inbound) neighbors. It is crucial to decide on a fixed number of neighbors, as the constant number decreases an eclipse probability exponentially. The chosen <em>k</em> is a compromise between having more connections resulting in lower performance and increased protection from an eclipse attack.</p><p>The operations involved during neighbor selection are listed in the following:</p><ol><li>Get an up-to-date list of verified and known peers from the <em>Peer Discovery</em> protocol. </li><li>Use <a href="#Mana_rank">mana rank</a> to filter the previous list to obtain a list of peers to be potential neighbors.</li><li>Use the score function to request/accept neighbors.</li></ol><p>The score between two nodes is measured through the score function <em>s</em>, defined by:</p><p>s(nodeID1, nodeID2, salt) = hash(nodeID1 || nodeID2 || salt), where:</p><ul><li><code>nodeID1</code> and <code>nodeID2</code> are the identities of the considered nodes.</li><li><code>salt</code> is the salt value that can be private or public depending on the peering direction (inbound/outbound).</li><li><code>hash</code> is the <code>blake2b</code> hash function.</li><li><code>||</code> is the concatanation operation.</li></ul><p>Note that the value used as the score is an unsigned integer derived from the first 4 bytes of the byte array after the <code>hash</code> function.</p><p>In order to connect to new neighbors, each node with ID <code>ownID</code> and public salt <code>pubSalt</code> keeps a list of potential neighbors derived via <a href="#Mana_rank">Mana rank</a> that is sorted by their score <code>d(ownID, ·, pubSalt)</code>. Then, the node shall send peering requests in <em>ascending order</em>, containing its own current public salt and a timestamp representing the issuance time of the request.
The connecting node shall repeat this process until it has established connections to enough neighbors or it finds closer peers. Those neighbors make up its list of chosen neighbors. This entire process is also illustrated in the following pseudocode:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Inputs: </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    k: desired amount of neighbors; </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    c: current list of chosen neighbors; </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    p: list of potential peers;</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    localID: local nodeID </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pubSalt: local public salt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly vbnet"><pre tabindex="0" class="prism-code language-vbnet codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pSorted = SortByScoreAsc(P, localID, pubSalt)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">FOR p IN pSorted</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    peeringRequest = SendPeeringRequest(p)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    IF peeringRequest.accepted </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Append(c, p)</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        IF Len(c) == Ceil(k/2) </span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            RETURN</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>More specifically, after sending a peering request a node <em>shall</em>:</p><ul><li>wait to get a <em>Peering Response</em> that could be positive or negative. <ul><li>If positive, add the peer to its chosen neighbor list</li><li>If negative, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li><li>If after <code>responseTimeout</code> no response is received, try again for a fixed <code>maxPeeringAttempts</code>. If not successful, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li></ul></li></ul><p>Similar to the previous case, in order to accept neighbors, every node with ID ownID <em>shall</em> generate a private salt <code>privSalt</code>.</p><p>Upon reception of a <em>Peering Request</em>, a peer <em>shall</em> make a decision to accept, reject or discard the request by:</p><ul><li>verifying that the signature of the <em>Peering Request</em> is valid and discard the request otherwise;</li><li>checking that the <code>timestamp</code> field is valid (i.e., not older than a given threshold <code>requestExpirationTime</code> specified by the node) and discard the request otherwise;</li><li>checking that the <em>mana</em> of the requester peer is within the own <a href="#Mana_rank">Mana rank</a> and send back a <em>negative</em> <em>Peering Response</em> otherwise;</li><li>checking that the requestor salt matches its hash chain by:<ul><li>taking the difference between the timestamp of the peering request and the time the initial salt was set, and then dividing this number by <code>saltUpdateInterval</code>, rounding down;</li><li>hashing the requester public salt as many times as the number of salt changes;</li><li>finally, if the result does not match the initial salt, discard the peering request;</li></ul></li><li>applying a statistical test to the request defined as <em>s(remoteID, ownID, ζ_remote) &lt; θ</em> for a fixed threshold θ, and discard it otherwise. <ul><li>this test determines the effectiveness of the brute force attack when an attacker tries to establish a connection with a desired peer;</li><li>with θ set to 0.01 an attacker has only 1% of chance of being successful;</li></ul></li><li>accept the peering request by sending back a <em>positive</em> <em>Peering Response</em> if either one of the following conditions is satisfied, and send back a <em>negative</em> <em>Peering Response</em> otherwise:<ul><li>the current size of the accepted neighbors list is smaller than <em>Floor(k/2)</em>; </li><li>the score defined as <em>s(ownID, remoteID, privSalt)</em> is lower than the current highest score among accepted neighbors. In this case, send a <em>Peering Drop</em> to drop the accepted neighbor with the highest score replaced by the requester peer. </li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="neighbor-removal"></a>Neighbor Removal<a class="hash-link" href="#neighbor-removal" title="Direct link to heading">#</a></h3><p>Neighbor removal can occur for several reasons:</p><ul><li>A node is replacing a neighbor with a better (in terms of score function) one;</li><li>From the gossip layer, the connection with a neighbor is lost;</li><li>If some form of reputation or bad behavior is being monitored, a neighbor could be dropped in case of misbehavior. For example, a node could respond to the peering request but choose not to gossip received messages.</li></ul><p>Independently from the reason, when a peer drops a neighbor <em>shall</em> send a <em>Peering Drop</em> and remove the neighbor from its requested/accepted neighbor list. Upon reception of a <em>Peering Drop</em>, the peer <em>shall</em> remove the dropping neighbor from its requested/accepted neighbor list.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/iotaledger/Goshimmer/tree/develop/docOps/docs/protocol_specification/autopeering.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/protocol_specification/tangle"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Tangle</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/protocol_specification/mana"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Mana Implementation »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#node-identities" class="table-of-contents__link">Node identities</a></li><li><a href="#peer-discovery" class="table-of-contents__link">Peer Discovery</a><ul><li><a href="#verification" class="table-of-contents__link">Verification</a></li><li><a href="#removal" class="table-of-contents__link">Removal</a></li><li><a href="#discovery" class="table-of-contents__link">Discovery</a></li></ul></li><li><a href="#neighbor-selection" class="table-of-contents__link">Neighbor Selection</a><ul><li><a href="#local-variables" class="table-of-contents__link">Local variables</a></li><li><a href="#mana-rank-interval" class="table-of-contents__link">Mana rank interval</a></li><li><a href="#selection" class="table-of-contents__link">Selection</a></li><li><a href="#neighbor-removal" class="table-of-contents__link">Neighbor Removal</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/welcome">Welcome</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQ</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tutorials/setup">Tutorials</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/implementation_design/event_driven_model">Implementation Design</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/protocol_specification">Protocol Specification</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/apis/api">API</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tooling">Tooling</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/teamresources/release">Team Resources</a></li></ul></div><div class="col footer__col"><div class="footer__title">Articles</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 IOTA Foundation, Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.dedbe278.js"></script>
<script src="/assets/js/main.0e69db9d.js"></script>
</body>
</html>