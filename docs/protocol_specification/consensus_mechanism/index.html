<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="GoShimmer Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="GoShimmer Blog Atom Feed">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons"><title data-react-helmet="true">Consensus Mechanism | GoShimmer</title><meta data-react-helmet="true" property="og:url" content="https://goshimmer.docs.iota.org//docs/protocol_specification/consensus_mechanism"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Consensus Mechanism | GoShimmer"><meta data-react-helmet="true" name="description" content="The consensus mechanism is necessary to achieve agreement among the nodes of the network. In case of a double spend, one way to decide which transaction should be considered valid would be to order them and pick the oldest one. However, the Tangle is only partially ordered. To tackle this problem in the context of the Tangle, we have designed an open and leaderless consensus mechanism. It combines a binary voting protocol (FPC) used as a pre-consensus to prevent metastable states, and a virtual voting protocol (Approval Weight) that provides finality similarly to the longest chain rule in Nakamoto consensus (i.e., heaviest branch)."><meta data-react-helmet="true" property="og:description" content="The consensus mechanism is necessary to achieve agreement among the nodes of the network. In case of a double spend, one way to decide which transaction should be considered valid would be to order them and pick the oldest one. However, the Tangle is only partially ordered. To tackle this problem in the context of the Tangle, we have designed an open and leaderless consensus mechanism. It combines a binary voting protocol (FPC) used as a pre-consensus to prevent metastable states, and a virtual voting protocol (Approval Weight) that provides finality similarly to the longest chain rule in Nakamoto consensus (i.e., heaviest branch)."><link data-react-helmet="true" rel="shortcut icon" href="/img/logo/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://goshimmer.docs.iota.org//docs/protocol_specification/consensus_mechanism"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/consensus_mechanism" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/consensus_mechanism" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.e8df95d8.css">
<link rel="preload" href="/assets/js/runtime~main.dedbe278.js" as="script">
<link rel="preload" href="/assets/js/main.0e69db9d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/welcome">Documentation</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/welcome">Documentation</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/welcome">Welcome</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/faq">FAQ</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/setup">Set up a node</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">Obtain tokens</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/wallet-library">Wallet library</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/dApp">Write a dApp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/manual_peering">Manual peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/static_identity">Create a static identity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/custom_dRNG">Set up a custom dRNG committee</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/monitoring">Set up the Monitoring Dashboard</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">How to create and send transactions</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Implementation design</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/event_driven_model">Event driven model</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/packages_plugins">Packages and plugins</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/plugin">Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/configuration_parameters">Configuration parameters</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/object_storage">Object storage</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Protocol Specification</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification">Protocol Specification</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/protocol">Protocol High Level Overview</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Components</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/components">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/tangle">Tangle</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/congestion_control">Congestion Control</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/protocol_specification/consensus_mechanism">Consensus Mechanism</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/ledgerstate">UTXO and Ledgerstate</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/advanced_outputs">Advanced Outputs (Experimental)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/markers">Markers</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/glossary">Glossary</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">API</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/api">Client Lib</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/webAPI">WebAPI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/info">Node Info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/manual_peering">Manual Peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/communication">Communication Layer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/ledgerstate">Ledgerstate</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/dRNG">dRNG</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/snapshot">Snapshot</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/faucet">Faucet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/spammer">Spammer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/tools">Tools</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tooling</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/docker_private_network">Docker Private Network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/integration_tests">Integration Tests</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Team Resources</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/release">How To Do a Release</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/guidelines">Code Guidelines</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/local_development">Local Development</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/analysis_dashboard">Modify the Analysis Dashboard</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">Consensus Mechanism</h1></header><p>The consensus mechanism is necessary to achieve agreement among the nodes of the network. In case of a double spend, one way to decide which transaction should be considered valid would be to order them and pick the oldest one. However, the Tangle is only partially ordered. To tackle this problem in the context of the Tangle, we have designed an open and leaderless consensus mechanism. It combines a binary voting protocol (FPC) used as a pre-consensus to prevent metastable states, and a virtual voting protocol (Approval Weight) that provides finality similarly to the longest chain rule in Nakamoto consensus (i.e., heaviest branch).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="fpc"></a>FPC<a class="hash-link" href="#fpc" title="Direct link to heading">#</a></h2><p>The <a href="https://arxiv.org/abs/1905.10895" target="_blank" rel="noopener noreferrer">Fast Probabilistic Consensus</a> (FPC) protocol is a binary voting protocol where each node starts with an initial opinion (a nulled boolean) on an object.  Nodes then exchange queries and responses about their opinions during several rounds, until each node terminates with a final boolean value.  </p><p>FPC votes on two specific objects types: messages, in order to enforce timestamps (currently not yet enabled in GoShimmer), and transactions, in order to decide double spends. Additionally, applications can use FPC to query opinions about their opinion on other object types, although there is no guarantee that they will get a response.  </p><p>The FPC is agnostic about the rest of the protocol, particularly when FPC should run and how the initial opinions are set. Deciding when FPC should run is a delicate question for two reasons.</p><ol><li>It is inefficient for FPC to vote on every single transaction.</li><li>If only a sub set of nodes participate in FPC, they are more vulnerable to attack since the consensus mana held by this collection of nodes is potentially much smaller.
Thus, since it cannot vote on everything, it must use subjective criterion to trigger voting which does not leave any group vulnerable to attack.</li></ol><p>For these reasons, we use <a href="#fcob">FCoB</a> to manage FPC.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="fcob"></a>FCoB<a class="hash-link" href="#fcob" title="Direct link to heading">#</a></h3><p>The following flow diagram shows the current implemention of the FCoB protocol.</p><p><img alt="FCoB" src="/assets/images/FCOB-33d2ddf7b609151732fb002020835c79.png"></p><p>Each opinion is associated to a <em>Level of Knowledge</em> (LoK) that defines how confident a node is with respect to the value of the opinion. We can distinguish 3 levels:</p><ul><li>Level 1 means that the node only knows that it holds this opinion.</li><li>Level 2 means that the node knows that all nodes have this opinion too (with high probability).</li><li>Level 3 means that the node knows that all nodes have level 2 knowledge (with high probability).</li></ul><p>Within FCoB, there are three cases which are treated:</p><ol><li>No conflicts have been detected</li><li>Conflicts have been detected but have been rejected</li><li>Conflicts have been detected are either pending or have been confirmed</li></ol><p>In Case 1 is the most common because conflicts will never arrive for most transactions. Without conflicts, the opinion can be only set provisionally since it might change if a conflict arrives later. The opinion is set to true, but the level is set as if a conflict arrived at that time.   For example, after a given <code>Quarantine</code> time has elapsed since arrival time, if a conflict does arrive the opinion will remain true with level at least 2.  </p><p>Case 2 is an important special case of the FCoB rule. To see the need for this modification consider the following example.  Suppose someone issues a pair of conflicting transactions where both transactions are rejected by FPC. Then, if someone ever issues a new transaction consuming those funds, FCoB, strictly speaking would reject the new transaction, since it would conflict with a previous transaction.  Thus, if a pair of double spends are rejected, the funds would be locked.  This is undesirable and impractical behavior: an honest but malfunctioning wallet can issue double spends.  Moreover, tracking the locked funds would be onerous. </p><p>Case 3 is the simplest case: since conflicts have been detected, we set the opinion according to the FCOB rule.  Then level is set according to the difference of <code>transaction.arrivalTime + Quarantine</code> and  <code>conflictTime</code>, the oldest arrival time of a conflicting transaction.  Essentially, the level measures how many network delays there are between these two values.   </p><p>To prevent the FCoB rule from locking funds, we modify it to the following: a transaction <code>X</code> satisfied the FCoB rule if all transactions <code>Y</code> conflicting with <code>X</code>  before <code>arrivalTime(X)+Quarantine</code> has been rejected, i.e. has has opinion false and level 2 or 3.  With this rule, any conflicts which are rejected will not affect the opinion on future conflicts.  For simplicity case, all transactions falling under this case are treated as level 1.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="fpc-statements"></a>FPC statements<a class="hash-link" href="#fpc-statements" title="Direct link to heading">#</a></h3><p>The FPC protocol requires nodes to directly query randomly selected nodes for conflict resolution. However, the information produced during such a voting mechanism is not stored in the Tangle, rather only lives within the node&#x27;s local metadata. This can be a problem for nodes joining the network at a later stage, specifically when a conflict is considered marked as level of knowledge 3 by the majority of the network, a new node cannot query it anymore.
Moreover, since the quorum to query is randomly formed proportionally to cMana, the highest cMana nodes would need to reply to too many queries, as their probability to be included in the quorum of each node is high.
We propose an optimization of the protocol that, in turn, should solve both of the above issues. The idea is to let each node be free to choose whether writing its opinion on a given conflict and a given FPC round on the Tangle. </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="payload"></a>Payload<a class="hash-link" href="#payload" title="Direct link to heading">#</a></h4><p>We need to first define the FPC Statement payload:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Statement </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   ConflictsCount  </span><span class="token builtin" style="color:rgb(189, 147, 249)">uint32</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Conflicts       Conflicts</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    TimestampsCount </span><span class="token builtin" style="color:rgb(189, 147, 249)">uint32</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Timestamps      Timestamps</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Conflict </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ID transaction</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ID</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Opinion</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Timestamp </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ID tangle</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">MessageID</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Opinion</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="registry"></a>Registry<a class="hash-link" href="#registry" title="Direct link to heading">#</a></h4><p>We also define an Opinion Registry where nodes can store and keep track of the opinions from each node after parsing FPC Statements.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Registry </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    nodesView </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">map</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">identity</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ID</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token operator">*</span><span class="token plain">View</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> View </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    NodeID     identity</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ID</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Conflicts  </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">map</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">transaction</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ID</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain">Opinions</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Timestamps </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">map</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">tangle</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">MessageID</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain">Opinions</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Given a nodeID and a ConflictID (or a messageID for timestamps), a node can check if it has the required opinion in its registry, and thus use that during its FPC round, or if not, send a traditional query to the node.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="broadcasting-an-fpc-statement"></a>Broadcasting an FPC Statement<a class="hash-link" href="#broadcasting-an-fpc-statement" title="Direct link to heading">#</a></h4><p>A node, after forming its opinion for 1 or more conflicts during an FPC round, can prepare an FPC statement containing the result of that round and issue it on the Tangle.
Currently, any node that belongs to the top 70% cMana issues FPC statements. This parameter is local to the node and can be changed by the node operator.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="drng"></a>dRNG<a class="hash-link" href="#drng" title="Direct link to heading">#</a></h2><p>At its core, the Fast Probabilistic Consensus (FPC) runs to resolve potential conflicting transactions by voting on them. FPC requires a random number generator (RNG) to be more resilient to an attack aiming at creating a meta-stable state, where nodes in the network are constantly toggling their opinion on a given transaction and thus are unable to finalize it. Such a RNG can be provided by either a trusted and centralized entity or be decentralized and distributed. Clearly, the fully decentralized nature of IOTA 2.0 mandates the latter option, and this option is referred to a distributed RNG (dRNG).</p><p>A dRNG can be implemented in very different ways, for instance by leveraging on cryptographic primitives such as verifiable secret sharing and threshold signatures,
by using cryptographic sortition or also with verifiable delay functions.
After reviewing some existing solutions, we decided to use a variant of the <a href="https://github.com/drand/drand" target="_blank" rel="noopener noreferrer">drand</a> protocol,
originally developed within the <a href="https://github.com/dedis" target="_blank" rel="noopener noreferrer">DEDIS organization</a>, and as of December 2019, is now under the drand organization.
This protocol has been already used by other projects such as <a href="https://www.cloudflare.com/leagueofentropy/" target="_blank" rel="noopener noreferrer">The League of Entropy</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="drand---a-distributed-randomness-beacon-daemon"></a>Drand - A Distributed Randomness Beacon Daemon<a class="hash-link" href="#drand---a-distributed-randomness-beacon-daemon" title="Direct link to heading">#</a></h3><p>Drand (pronounced &quot;dee-rand&quot;) is a distributed randomness beacon daemon written
in <a href="https://golang.org/" target="_blank" rel="noopener noreferrer">Golang</a>. Servers running drand can be linked with each
other to produce collective, publicly verifiable, unbiased, unpredictable
random values at fixed intervals using bilinear pairings and threshold
cryptography. Drand nodes can also serve locally-generated private randomness
to clients.</p><p>In a nutshell, drand works in two phases: <strong>setup</strong> and <strong>generation</strong>.
In the setup phase, a set of nodes (hereafter referred as ‚Äúcommittee‚Äù) run a distributed key generation (DKG) protocol
to create a collective private and public key pair shared among the members of the committee.
More specifically, at the end of this phase, each member obtains a copy of the public key as well as a private key share of the collective private key,
such that no individual member knows the entire collective private key.
These private key shares will then be used by the committee members to sign their contributions during the next phase.
The generation phase works in discrete rounds.
In every round, the committee produces a new random value by leveraging on a deterministic threshold signature scheme such as BLS.
Each member of the committee creates in round <em>r</em> the partial BLS signature <em>œÉ_r</em> on the message <em>m=H(r || œÇ_r-1)</em>
where <em>œÇ_r-1</em> denotes the full BLS threshold signature from the previous round <em>r‚àí1</em> and <em>H</em> is a cryptographic hash function.
Once at least <em>t</em> members have broadcasted their partial signatures <em>œÉ_r</em> on <em>m</em>,
anyone can recover the full BLS threshold signature <em>œÇ_r</em> (via Lagrange interpolation) which corresponds to the random value of round <em>r</em>.
Then, the committee moves to the next round and reiterates the above process. For the first round, each member signs a seed fixed during the setup phase.
This process ensures that every new random value depends on all previously generated signatures.
If you are interested in knowing more about drand, we recommend you to check out their <a href="https://github.com/drand/drand" target="_blank" rel="noopener noreferrer">Github repository</a>.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="approval-weight-aw"></a>Approval Weight (AW)<a class="hash-link" href="#approval-weight-aw" title="Direct link to heading">#</a></h2><p>Approval weight represents the <a href="#active-consensus-mana">weight</a> of branches (and messages), similar to the longest chain rule in Nakamoto consensus. However, instead of selecting a leader based on a puzzle (PoW) or stake (PoS), it allows every node to express its opinion by simply issuing any message and attaching it in a part of the Tangle it <em>likes</em> (based on FCoB/FPC). This process is also known as virtual voting, and has been previously described in <a href="https://medium.com/@hans_94488/a-new-consensus-the-tangle-multiverse-part-1-da4cb2a69772" target="_blank" rel="noopener noreferrer">On Tangle Voting</a>. </p><p>If a node realizes its opinion according to FCoB/FPC differs from that of the majority of weight, it has to do a reorg of its perception according to the heavier branch. In that way, all nodes will eventually converge to the heaviest branches, and, thus, come to consensus efficiently. </p><p>AW also serves as a probabilistic finality tool for individual messages and their payloads, i.e., transactions.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalization"></a>Finalization<a class="hash-link" href="#finalization" title="Direct link to heading">#</a></h3><p>Finality must always be considered as a probabilistic finality in the sense that a message is included in the ledger with a very high probability. Two qualities desired from a finality criteria are fast confirmation rate and a high probability of non-reversibility. </p><p>A branch is considered finalized/confirmed if one of the following holds:</p><ol><li>It is the <em>MasterBranch</em>.</li><li>Its approval weight is at least <em>0.5</em> higher than any of its conflicting branches. </li></ol><p>A message is considered finalized/confirmed if the following holds:</p><ol><li>Its approval weight is higher than <em>0.5</em>, and its branch is confirmed.</li></ol><p>Conversely, a message that does not gather enough AW will not be finalized, and, thus, will be pending until it might be orphaned if not reachable via current tips anymore.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="detailed-design"></a>Detailed Design<a class="hash-link" href="#detailed-design" title="Direct link to heading">#</a></h3><p>Approval weight is tracked with the help of supporters that cast votes for branches and messages by means of making statements. This is necessary due to the changing nature of cMana over time, which prevents simply counting the AW per branch or message. </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="definitions"></a>Definitions<a class="hash-link" href="#definitions" title="Direct link to heading">#</a></h4><ul><li><strong>Statement</strong>: A statement is any message issued by a <em>node</em>, expressing its opinion and casting a (virtual) vote. It can be objectively ordered by its timestamp, and, if equal, its message ID.</li><li><strong>Branch supporter</strong>: A branch supporter is a <em>node</em> that issued a statement attaching to a branch, and, thus, voting for it.</li><li><strong>Marker/message supporter</strong>: A marker/message&#x27;s supporter is a <em>node</em> that issued a statement directly or indirectly referencing a marker/message, including its issuer.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="branches"></a>Branches<a class="hash-link" href="#branches" title="Direct link to heading">#</a></h4><p>Tracking supporters of branches and following the heavier branch effectively is On Tangle Voting. It allows nodes to express their opinion simply by attaching a statement to a branch they like. This statement needs to propagate down the branch DAG, adding support to each of the branch parents. In case a supporter changes their opinion, support needs to be revoked from all conflicting branches and their children. Thus, a node can only support one branch of a conflict set. </p><p>To make this more clear consider the following example:
<img alt="Branch Supporter" src="/assets/images/branches-c0c4ec96cd0978505cf904170f8aa1c1.png"></p><p>The green node issued <strong>statement 1</strong> and attached it to the aggregated branch <code>Branch 1.1 + Branch 4.1.1</code>. Thus, the green node is a supporter of all the aggregated branch&#x27;s parent branches, which are (from top to bottom) <code>Branch 4.1.1</code>, <code>Branch 1.1</code>, <code>Branch 4.1</code>, <code>Branch 1</code>, and <code>Branch 4</code>.</p><p>Then, the green node issued <strong>statement 2</strong> and attached it to <code>Branch 4.1.2</code>. This makes the green node a supporter of <code>Branch 4.1.2</code>, however, <code>Branch 4.1.1</code> is its conflict branch and thus support for <code>Branch 4.1.1</code> has to be revoked.</p><p><code>Branch 4.1</code>, <code>Branch 4</code> are parent branches of <code>Branch 4.1.2</code>, which the green node is still supporting. Since <code>Branch 1.1</code>, <code>Branch 1</code> are not conflicting to either of <code>Branch 4.1.2</code>&#x27;s parents, the green node remains their supporter.</p><p>Finally, the green nodes issued <strong>statement 3</strong>, which is in <code>Branch 2</code>. Now the green node is a supporter of <code>Branch 2</code>, and no longer a supporter of <code>Branch 1</code>, since <code>Branch 1</code> is conflicting to <code>Branch 2</code>. Note that, this supporter removal will propagate to child branches. Thus, the green node is removed from <code>Branch 1.1</code> as well.
<code>Branch 3</code>, <code>4</code> and both of their child branches have nothing to do with this attachement, the supporter status remains.</p><p>It is important to notice that the arrival order of the statements does not make a difference on the final outcome. Due to the fact that statements can be ordered objectively, every node in the network eventually comes to the same conclusion as to who is supporting which branch, even when nodes change their opinion.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="calculation-of-approval-weight"></a>Calculation of Approval Weight<a class="hash-link" href="#calculation-of-approval-weight" title="Direct link to heading">#</a></h5><p>The approval weight itself is calculated every time a new supporter is added to a branch. The AW for a branch <em>B</em> is calculated as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">AW(B) = supporters(B) dot &#x27;active cMana nodes&#x27; / &#x27;total active cMana&#x27;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It is then evaluated whether it fulfills the <a href="#finalization">finalization</a> criterion. If so, the branch is set to <em>confirmed</em>, while all its conflicts are set to <em>rejected</em>.</p><p><strong>Reorg</strong>: In case the node confirmed another branch of the conflict set first, e.g., because of a difference in perception of the ledger state, it will have to do reorg. This means, the node needs to adjust its perception of the ledger state, so that, eventually, all nodes converge and follow the heaviest branch by active cMana.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="markers"></a>Markers<a class="hash-link" href="#markers" title="Direct link to heading">#</a></h4><p>It would be computationally expensive to track the AW for each message individually. Instead, we approximate the AW with the help of <a href="/docs/protocol_specification/markers">markers</a>. Once a marker fulfills the <a href="#finalization">finalization</a> criterion, the confirmation is propagated into its past cone until all the messages are confirmed.</p><p>Rather than keeping a list of supporters for each marker and collecting supporters for each marker (which would also be expensive), we keep a list of supporters along with its approved marker index for each marker sequence. This approach provides a simple and fast look-up for marker supporters making use of the Tangle structure as mapped by the markers.</p><p>For each marker sequence, we keep a map of supporter to marker index, meaning a supporter supports a marker index <code>i</code>. This implies that the supporter supports all markers with index <code>&lt;= i</code>.</p><p>Take the figure below as an example:
<img src="https://user-images.githubusercontent.com/11289354/112416694-21012780-8d61-11eb-8089-cb9f5b236f30.png" alt="MarkersApprovalWeight SequenceSupporters-Page-2"></p><p>The purple circles represent markers of the same sequence, the numbers are marker indices.</p><p>Four nodes (A to D) issue statements with past markers of the purple sequence. Node A and D issue messages having past marker with index 6, thus node A and D are the supporters of marker 6 and all markers before, which is 1 to 5. On the other hand, node B issues a message having past marker with index 3, which implies node B is a supporter for marker 1 and 2 as well.</p><p>This is a fast look-up and avoids walking through a marker&#x27;s future cone when it comes to retrieving supporters for approval weight calculation.</p><p>For example, to find all supporter of marker 2, we iterate through the map and filter out those support marker with <code>index &gt;= 2</code>. In this case, all nodes are its supporters. As for marker 5, it has supporters node A and D, which fulfill the check: <code>index &gt;= 5</code>.</p><p>Here is another more complicated example with parent sequences:
<img src="https://user-images.githubusercontent.com/11289354/112433680-8cf18900-8d7d-11eb-8944-54030581a033.png" alt="MarkersApprovalWeight SequenceSupporters-Page-2(1)"></p><p>The supporter will be propagated to the parent sequence.</p><p>Node A issues message A2 having past markers <code>[1,4], [3,5]</code>, which implies node A is a supporter for marker <code>[1,1]</code> to <code>[1,4]</code>, <code>[2,1]</code> to <code>[2,3]</code>, and <code>[3,4], [3,5]</code> as well.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="calculation-of-approval-weight-1"></a>Calculation of Approval Weight<a class="hash-link" href="#calculation-of-approval-weight-1" title="Direct link to heading">#</a></h5><p>The approval weight itself is calculated every time a new supporter is added to a marker, and the marker&#x27;s branch <em>B</em> has reached its finality criterion. The AW for a marker <em>M</em> is calculated as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">AW(M) = supporters(B) dot supporters(M) dot &#x27;active cMana nodes&#x27; / &#x27;total active cMana&#x27;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It is then evaluated whether it fulfills the <a href="#finalization">finalization</a> criterion. If so, the marker&#x27;s message is set to <em>confirmed</em> as well as all messages in its past cone.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="active-consensus-mana"></a>Active Consensus Mana<a class="hash-link" href="#active-consensus-mana" title="Direct link to heading">#</a></h2><p>It is important to track the currently <em>active</em> consensus mana in the system, such that the AW of a given message and/or branch reflects an up-to-date measure of cumulative weight. Specifically, the system must be resilient against a long-range attack.</p><p>The active consensus mana tracks the set of the active nodes with some conensus mana. A node is considered to be active if it has issued any message in the last 30 minutes with respect to the TangleTime. The total active consensus mana is, therefore, the sum of all the consensus mana of each active node.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/iotaledger/Goshimmer/tree/develop/docOps/docs/protocol_specification/consensus_mechanism.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/protocol_specification/congestion_control"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Congestion Control</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/protocol_specification/ledgerstate"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ledgerstate ¬ª</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#fpc" class="table-of-contents__link">FPC</a><ul><li><a href="#fcob" class="table-of-contents__link">FCoB</a></li><li><a href="#fpc-statements" class="table-of-contents__link">FPC statements</a></li></ul></li><li><a href="#drng" class="table-of-contents__link">dRNG</a><ul><li><a href="#drand---a-distributed-randomness-beacon-daemon" class="table-of-contents__link">Drand - A Distributed Randomness Beacon Daemon</a></li></ul></li><li><a href="#approval-weight-aw" class="table-of-contents__link">Approval Weight (AW)</a><ul><li><a href="#finalization" class="table-of-contents__link">Finalization</a></li><li><a href="#detailed-design" class="table-of-contents__link">Detailed Design</a></li></ul></li><li><a href="#active-consensus-mana" class="table-of-contents__link">Active Consensus Mana</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/welcome">Welcome</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQ</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tutorials/setup">Tutorials</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/implementation_design/event_driven_model">Implementation Design</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/protocol_specification">Protocol Specification</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/apis/api">API</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tooling">Tooling</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/teamresources/release">Team Resources</a></li></ul></div><div class="col footer__col"><div class="footer__title">Articles</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2021 IOTA Foundation, Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.dedbe278.js"></script>
<script src="/assets/js/main.0e69db9d.js"></script>
</body>
</html>