<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="GoShimmer Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="GoShimmer Blog Atom Feed">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Material+Icons"><title data-react-helmet="true">UTXO Output Types | GoShimmer</title><meta data-react-helmet="true" property="og:url" content="https://goshimmer.docs.iota.org//docs/protocol_specification/advanced_outputs"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="UTXO Output Types | GoShimmer"><meta data-react-helmet="true" name="description" content="Motivation"><meta data-react-helmet="true" property="og:description" content="Motivation"><link data-react-helmet="true" rel="shortcut icon" href="/img/logo/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://goshimmer.docs.iota.org//docs/protocol_specification/advanced_outputs"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/advanced_outputs" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://goshimmer.docs.iota.org//docs/protocol_specification/advanced_outputs" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.e8df95d8.css">
<link rel="preload" href="/assets/js/runtime~main.dedbe278.js" as="script">
<link rel="preload" href="/assets/js/main.0e69db9d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/welcome">Documentation</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo/Logo_Swirl_Dark.png" alt="IOTA" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">GoShimmer</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/docs/welcome">Documentation</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/welcome">Welcome</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/faq">FAQ</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/setup">Set up a node</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">Obtain tokens</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/wallet-library">Wallet library</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/dApp">Write a dApp</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/manual_peering">Manual peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/static_identity">Create a static identity</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/custom_dRNG">Set up a custom dRNG committee</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/monitoring">Set up the Monitoring Dashboard</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tutorials/send_transaction">How to create and send transactions</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Implementation design</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/event_driven_model">Event driven model</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/packages_plugins">Packages and plugins</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/plugin">Plugin</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/configuration_parameters">Configuration parameters</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/implementation_design/object_storage">Object storage</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Protocol Specification</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification">Protocol Specification</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/protocol">Protocol High Level Overview</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Components</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/components">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/tangle">Tangle</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/congestion_control">Congestion Control</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/consensus_mechanism">Consensus Mechanism</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/ledgerstate">UTXO and Ledgerstate</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/protocol_specification/advanced_outputs">Advanced Outputs (Experimental)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/markers">Markers</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/protocol_specification/glossary">Glossary</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">API</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/api">Client Lib</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/webAPI">WebAPI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/info">Node Info</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/autopeering">Autopeering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/manual_peering">Manual Peering</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/communication">Communication Layer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/ledgerstate">Ledgerstate</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/mana">Mana</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/dRNG">dRNG</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/snapshot">Snapshot</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/faucet">Faucet</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/spammer">Spammer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/apis/tools">Tools</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Tooling</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling">Overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/docker_private_network">Docker Private Network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tooling/integration_tests">Integration Tests</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Team Resources</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/release">How To Do a Release</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/guidelines">Code Guidelines</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/local_development">Local Development</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/teamresources/analysis_dashboard">Modify the Analysis Dashboard</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">UTXO Output Types</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="motivation"></a>Motivation<a class="hash-link" href="#motivation" title="Direct link to heading">#</a></h2><p>In the previous <a href="/docs/protocol_specification/ledgerstate">section</a> two basic output types were introduced that enable the use of the UTXO ledger
as a payment application between addresses. Each <code>SigLockedSingleOutput</code> and <code>SigLockedAssetOutput</code> encodes a list of
balances and an address in the output. The output can be unlocked by providing a valid signature for the address, hence
only the owner of the address can initiate a payment.</p><p>While these two output types provide the basic functionality for a cryptocurrency application, IOTA aims to strive
for more. The first and foremost application the UTXO ledger should support besides payments is the IOTA Smart Contract
Protocol (ISCP). Due to the lack of total ordering of the Tangle (that is a direct result of the scalable, parallel
architecture), it is not possible to implement Turing-complete smart contracts directly on layer 1. Therefore,
IOTA aims to develop a layer 2 protocol called ISCP for smart contracts.</p><p>After carefully evaluating the proposed architecture of ISCP and the required properties of the layer 2 protocol, we
came up with special types of outputs for layer 1 UTXO support: <code>AliasOutput</code> and <code>ExtendedLockedOutput</code>.
These output types are experimental: the IOTA 2.0 DevNet serves as their testing ground. Bear in mind that there is no
guarantee that they will not change as the protocol evolves.</p><p>It will be demonstrated later that these outputs can also be used for enhanced cryptocurrency payment application, such
as conditional payments or time locked sending, but also open up the world of native non-fungible tokens (NFTs).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="functional-requirements-of-iscp"></a>Functional Requirements of ISCP<a class="hash-link" href="#functional-requirements-of-iscp" title="Direct link to heading">#</a></h2><p>Designing the output types starts with a proper requirement analysis. Below you can read the summary of the functional
requirements imposed by the layer 2 smart contract protocol. You can read more about ISCP
<a href="https://blog.iota.org/an-introduction-to-iota-smart-contracts-16ea6f247936/" target="_blank" rel="noopener noreferrer">here</a>,
<a href="https://blog.iota.org/iota-smart-contracts-protocol-alpha-release/" target="_blank" rel="noopener noreferrer">here</a>
or check out this <a href="https://youtu.be/T1CJFr6gz8I" target="_blank" rel="noopener noreferrer">presentation</a>.</p><ul><li>Smart contract chains need a globally unique account in the UTXO ledger, that does not change if the controlling entities changes.</li><li>An account state is identified by balances and state metadata.</li><li>Two levels of control: <strong>state controller</strong> and <strong>governance controller</strong>.</li><li>State controller can change state metadata (state transition) and balance (min required).</li><li>Governance controller can change state controller and governance controller.</li><li>An account shall have only one valid state in the ledger.</li><li>Smart contract chain state transitions are triggered by requests in the ledger.</li><li>A request is a ledger entity belonging to the account with tokens and data.</li><li>The account can identify and control requests.</li><li>Fallback mechanism needs to be in place in case the requests are not picked up.</li><li>When request is completed in a state transition, it should be atomically removed from the ledger.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="output-design"></a>Output Design<a class="hash-link" href="#output-design" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="introducing-alias-account"></a>Introducing Alias Account<a class="hash-link" href="#introducing-alias-account" title="Direct link to heading">#</a></h3><p>Previously, the account concept in the ledger was realized with cryptographic entities called addresses, that are backed
by public and private key pairs. Addresses are present in the ledger through outputs and define who can spend this
output by providing a digital signature.</p><p>Addresses are not able to provide the necessary functionality needed for smart contract chain accounts, because:</p><ul><li>addresses change with the rotation of the controlling body (committee),</li><li>and there is no notion of separate control levels for an address account.</li></ul><p>We define a new account type in the ledger, called <strong>Alias</strong>, to represent smart contract chain accounts. An alias
account can hold token balances, but also has state metadata, which stores the state of the smart contract chain.
The alias account defines two to controlling entities: a state controller and a governance controller. The state
controller can transition the account into a new state, and can manipulate account balances. The governance controller
can change the state controller or the governance controller.</p><p>An alias is not a cryptographic entity, but it is controlled via either regular addresses or other aliases.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="representing-a-smart-contract-chain-account-in-ledger"></a>Representing a Smart Contract Chain Account in Ledger<a class="hash-link" href="#representing-a-smart-contract-chain-account-in-ledger" title="Direct link to heading">#</a></h3><p>An alias is translated into the ledger as a distinct output type, called <strong>AliasOutput</strong>. The output contains:</p><ul><li>the unique identifier of the alias, called <strong>AliasID</strong>,</li><li>the <strong>State Controller</strong> entity,</li><li><strong>State Metadata</strong>,</li><li>the <strong>Governance Controller</strong>,</li><li><strong>Governance Metadata</strong>,</li><li><strong>Immutable Metadata</strong>,</li><li>and token <strong>balances</strong>.</li></ul><p>The state controller and governance controller entities can either be private key backed addresses (cryptographic
entities) or <code>AliasAddress</code>, that is the unique identifier of another alias. Note, that an alias cannot be controlled by
its own <code>aliasID</code>.</p><p>An alias output itself can be regarded as a non-fungible token with a unique identifier <code>aliasID</code>, metadata and token
balances. An NFT that can hold tokens, can control its metadata and has a governance model.</p><p>Alias output can be created in a transaction that spends the minimum required amount of tokens into a freshly created
alias output. The new transaction output specifies the state and governance controller next to the balances, but aliasID
is assigned by the protocol once the transaction is processed. Once the output is booked, aliasID becomes the hash of
the outputID that created it.</p><p>An alias output can only be destroyed by the governance controller by simply consuming it as an input but not creating
a corresponding output in the transaction.</p><p>The alias account is transitioned into a new state by spending its alias output in a transaction and creating an
updated alias output with the same aliasID. Depending on what unlocking conditions are met, there are certain
restrictions on how the newly created alias output can look like.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="consuming-an-alias-output"></a>Consuming an Alias Output<a class="hash-link" href="#consuming-an-alias-output" title="Direct link to heading">#</a></h3><p>As mentioned above, an alias output can be unlocked by both the state controller and the governance controller.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="unlocking-via-state-controller"></a>Unlocking via State Controller<a class="hash-link" href="#unlocking-via-state-controller" title="Direct link to heading">#</a></h4><p>When the state controller is an address, the alias output is unlocked by providing a signature of the state controller
address in the output that signs the essence of the transaction. When state controller is another alias, unlocking is
done by providing a reference to the state controller unlocked other alias within the transaction.</p><p>When an alias output is unlocked as input in a transaction by the state controller, the transaction must contain a
corresponding alias output. Only the state metadata and the token balances of the alias output are allowed to change,
and token balances must be at least a protocol defined constant.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="unlocking-via-governance-controller"></a>Unlocking via Governance Controller<a class="hash-link" href="#unlocking-via-governance-controller" title="Direct link to heading">#</a></h4><p>The governance controller is either an address, or another alias. In the former case, unlocking is done via the regular
signature. In the latter case, unlocking is done by providing a reference to the unlocked governance alias within the
transaction.</p><p>When an alias output is unlocked as input by the governance controller, the transaction doesn&#x27;t need to have a
corresponding output. If there is no such output in the transaction, the alias is destroyed. If however the output
is present, only the state and governance controller fields are allowed to be changed.</p><p>A governance controller therefore can:</p><ul><li>destroy the alias all together,</li><li>assign the state controller of the alias,</li><li>assign the governance controller of the alias.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="locking-funds-into-aliases"></a>Locking Funds Into Aliases<a class="hash-link" href="#locking-funds-into-aliases" title="Direct link to heading">#</a></h2><p>Address accounts in the ledger can receive funds by the means of signature locking. Outputs specify an address field,
which essentially gives the control of the funds of the output to the owner of the address account, the holder of the
corresponding private key.</p><p>In order to make alias accounts (smart contract chains) able to receive funds, we need to define a new fund locking
mechanism, called alias locking. An alias locked output can be unlocked by unlocking the given alias output for
state transition in the very same transaction.</p><p>An alias account (smart contract chain) can receive funds now, but there are additional requirements to be satisfied
for smart contracts:</p><ul><li>Alias locked outputs represent smart contract requests, and hence, need to contain metadata that is interpreted on
layer 2.</li><li>A dormant smart contract chain might never consume alias locked outputs, therefore, there needs to be a fallback
mechanism for the user to reclaim the funds locked into the request.</li><li>Requests might be scheduled by the user by specifying a time locking condition on the output. The output can not be
spent before the time locking period expires.</li></ul><p>As we can see, there are couple new concepts regarding outputs that we need to support for the smart contract use case:</p><ul><li><strong>alias locking</strong></li><li><strong>metadata tied to output</strong></li><li><strong>fallback unlocking mechanism</strong></li><li><strong>time locking</strong></li></ul><p>In the next section, we are going to design an <strong>Extended Output</strong> model that can support these concepts.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="extended-output"></a>Extended Output<a class="hash-link" href="#extended-output" title="Direct link to heading">#</a></h2><p>An extended output is an output that supports alias locking, output metadata, fallback unlocking mechanisms and time
locking. The structure of an extended output is as follows:</p><p>Extended Output:</p><ul><li><strong>AliasID</strong>: the alias account that is allowed to unlock this output.</li><li><strong>Token Balances</strong>: tokens locked by the output.</li><li><strong>Metadata</strong>: optional, bounded size binary data.</li><li><strong>FallbackAccount</strong>: an alias or address that can unlock the output after <strong>FallbackDeadline</strong>.</li><li><strong>FallbackDeadline</strong>: a point in time after which the output might be unlocked by <strong>FallbackAccount</strong>.</li><li><strong>Timelock</strong> (Optional): a point in time. When present, the output can not be unlocked before.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="unlocking-via-aliasid"></a>Unlocking via AliasID<a class="hash-link" href="#unlocking-via-aliasid" title="Direct link to heading">#</a></h3><p>The extended output can be unlocked by unlocking the alias output with aliasID by the state controller within the same
transaction. The unlock block of an extended output then references the unlock block of the corresponding alias output.</p><p>Aliases abstract away the underlying address of a smart contract committee, so when a committee is rotated, <code>aliasID</code>
stays the same, but the address where the alias points to can be changed.</p><p>It is trivial then to define the unique account of a smart contract on layer 1 as the <code>aliasID</code>, however, a new locking
mechanism is needed on the UTXO layer to be able to tie funds to an alias.</p><p>Previously, only addresses defined accounts in the protocol. Funds can be locked into addresses, and a signature of the
respective address has to be provided in the transaction to spend funds the account.</p><p>With the help of aliases, it is possible to extend the capabilities of the protocol to support locking funds into
aliases. This is what we call alias locking. An alias locked output specifies an <code>aliasID</code> that can spend the funds
from this output. The owner of the alias account can spend aforementioned alias locked outputs by unlocking/moving the
alias in the very same transaction. We will use the term <code>ExtendedLockedOutput</code> for outputs that support alias locking.</p><p>Let&#x27;s illustrate this through a simple example. Alice wants to send 10 Mi to Bob&#x27;s alias account. Bob then wants to
spend the 10 Mi from his alias account to his address account.</p><ol><li>Bob creates an alias where <code>aliasID=BobAliasID</code> with Transaction A.</li></ol><p><img alt="Bob creates an alias" src="/assets/images/bob_alias-2b8903e0a4d7f6141a36d05e3887e636.png" title="Bob creates an alias"></p><ol start="2"><li>Bob shares <code>BobAliasID</code> with Alice.</li><li>Alice sends 10 Mi to Bob by sending Transaction B that creates an <code>ExtendedLockedOutput</code>, specifying the balance,
and <code>aliasID=BobAliasID</code>.</li></ol><p><img alt="Alice sends 10 Mi to Bob" src="/assets/images/alice_sends_10_mi-fae374f2f279915ca00b1e941f886406.png" title="Alice sends 10 Mi to Bob"></p><ol start="4"><li>Bob can spend the outputs created by Alice by creating Transaction C that moves his <code>BobAlias</code> (to the very same
address), and including the  <code>ExtendedLockedOutput</code> with <code>aliasID=BobAliasID</code>.</li></ol><p><img alt="Bob can spend the outputs created by Alice by creating Transaction C" src="/assets/images/bob_can_spend_outputs_created_by_alice-95640050f296884898785699f4962795.png" title="Bob can spend the outputs created by Alice by creating Transaction C"></p><p>In a simple scenario, a user wishing to send a request to a smart contract creates an extended output. The output
contains the AliasID of the smart contract chain account, the layer 2 request as metadata, and some tokens to pay
for the request. Once the transaction is confirmed, the smart contract chain account &quot;receives&quot; the output. It
interprets the request metadata, carries out the requested operation in its chain, and submits a transaction that
contains the updated smart contract chain state (alias output), and also spends the extended output to increase
the balance of its alias output.</p><p>What happens when the smart contract chain goes offline or dies completely? How do we prevent the extended output to
be lost forever?</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="unlocking-via-fallback"></a>Unlocking via Fallback<a class="hash-link" href="#unlocking-via-fallback" title="Direct link to heading">#</a></h3><p>Extended outputs can also define a fallback account and a fallback deadline. After the fallback deadline, only the
fallback account is authorized to unlock the extended output. Fallback deadline cannot be smaller than a protocol
wide constant to give enough time to the smart contract chain to pick up the request.</p><p>Fallback unlocking can either be done via signature unlocking or alias unlocking, depending on the type  of account
specified.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="timelock"></a>Timelock<a class="hash-link" href="#timelock" title="Direct link to heading">#</a></h3><p>Timelocking outputs is a desired operation not only for smart contracts, but for other use cases as well. A user might
for example scheduled a request to a smart contract chain at a later point in time by timelocking the extended output
for a certain period.</p><p>Timelocks can be implemented quite easily if transactions have enforced timestamps: the output can not be unlocked if
the transaction timestamp is before the timelock specified in the output.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="notes"></a>Notes<a class="hash-link" href="#notes" title="Direct link to heading">#</a></h2><p>One of the most important change that the new output types imply is that checking the validity of an unlock block of a
certain consumed input has to be done in the context of the transaction. Previously, an unlock block was valid if the
provided signature was valid. Now, even if the signature is valid for an alias output unlocked for state transition,
additional constraints also have to be met.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="how-does-it-work-for-iscp"></a>How does it work for ISCP?<a class="hash-link" href="#how-does-it-work-for-iscp" title="Direct link to heading">#</a></h2><ul><li>The new output types are completely orthogonal to colored coins, ISCP will not rely on them anymore.</li><li>The Alias output functions as a chain constraint to allow building a non-forkable chain of transactions in the
ledger by the state controller. The alias output holds tokens, that are the balance of the smart contract chain.
The hash of the smart contract chain state is stored in the alias output, registering each state transition as a
transaction on the ledger.</li><li>The governance controller of an alias output can change the state controller, meaning that a committee rotation can
be carried out without changing the smart contract chain account, aliasID.<ul><li>A smart contract chain can be self governed, if the state and governance controllers coincide.</li><li>A smart contract chain can be governed by an address account, or by another smart contract chain through an
alias account.</li></ul></li><li>Each Extended Output is a request which is ‚Äúsent‚Äù to the alias account. The ISCP can retrieve the backlog of
requests by retrieving all outputs for the aliasID. Consuming the Extended Output means it is atomically removed
from the backlog. It can only be done by the state controller, i.e. the committee of the smart contract chain.</li><li>Fallback parameters prevent from losing funds if the committee is inactive for some timeout. After timeout the
Extended Output can be unlocked by FallbackAccount, an address or another alias.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="additional-use-cases"></a>Additional Use Cases<a class="hash-link" href="#additional-use-cases" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="delegated-keys"></a>Delegated Keys<a class="hash-link" href="#delegated-keys" title="Direct link to heading">#</a></h3><p>An alias output is controlled by two parties: the state controller and the governance controller. The state controller
can only change the state metadata and the tokens when spending the output, therefore it only has the right to move the
alias to the very same account in a transaction. The governance controller however can change the state controller, or
destroy the alias and hence release the funds locked into it.</p><p>This makes it an ideal candidate for mana delegation, that is a crucial part of a mana marketplace. In Coordidice,
moving funds generate access and consensus mana. Alias outputs make it possible to delegate the right to move funds
without losing control over them.</p><ol><li>An account owning funds create an alias output and locks funds into it. The governance controller of the alias output
shall be <code>ownAccount</code>.</li><li>An entity in need of mana generated by the locked funds can purchase the right from the governance controller to
move the alias output, generating mana.</li><li>Once purchased, the governance controller updates the alias output by specifying the state controller to be
<code>buyerAccount</code>.</li><li><code>buyerAccount</code> now can move the alias output, but only to its own account. Each move generates (access) mana.</li><li>Since <code>ownAccount</code> is the governance controller, it can revoke <code>buyerAccount</code>&#x27;s state controlling right at any point
in time.</li><li><code>ownAccount</code> can also destroy the alias and &quot;free&quot; the locked funds.</li></ol><p>Notes:</p><ul><li>The state controller can redeem funds from the alias output up to the point where only <code>minimum allowed amount</code> is
present in the alias output. Therefore, without additional mechanism, it would only make sense to lock
<code>minimum allowed amount</code> into an alias by the governance controller. This is obviously a drawback, users should not
be restricted in how many funds they would like to delegate.</li><li>A governance controller can destroy the alias output at any time, which is not desired from the buyer perspective.
The buyer should be able to buy the right to move the funds for a pre-defined amount of time.</li></ul><p>To solve above problems, the <code>AliasOutput</code> currently implemented in GoShimmer supports the delegation use case by
introducing two new fields in the output:</p><ul><li><code>isDelegated</code> and</li><li><code>delegationTimelock</code>.</li></ul><p>When an alias is delegated, the state controller cannot modify token balances, and the governor can destroy the
output with any balance. However, when delegation time lock is present, the governor is not allowed to unlock the
output until the delegation time expires.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="non-fungible-tokens"></a>Non-Fungible Tokens<a class="hash-link" href="#non-fungible-tokens" title="Direct link to heading">#</a></h3><p>NFTs are unique tokens that have metadata attached to them. Since an AliasOutput implements a chain constraint in the
UTXO ledger, it is perfectly suited to represent NFTs. The unique identifier of the NFT is the <code>aliasID</code> or <code>AliasAddress</code>.
The <code>Immutable Data</code> field of the output can only be defined upon creation and can&#x27;t be changed afterwards, therefore
it is perfect to store metadata belonging to the NFT.</p><p>The ID of an IOTA NFT is also a valid address, therefore the NFT itself can receive and manage funds and other NFTs as
well. Refer to the <a href="/docs/tutorials/wallet-library">cli-wallet tutorial</a> for an overview of what you can do with an NFT.</p><p>Interestingly, minting an IOTA NFT costs you only the minimum required deposit balance (0.0001 MI at the moment), which
you can take back when you destroy the NFT. This is required so that NFTs are not minted out of thin air, and there are
some IOTAs backing the output. Otherwise, the ledger database could be easily spammed.
Transferring NFTs is also feeless, just like any other transaction in IOTA.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="goshimmer-implementation"></a>GoShimmer Implementation<a class="hash-link" href="#goshimmer-implementation" title="Direct link to heading">#</a></h2><p>If you are interested, you can find the GoShimmer implementation of the new ouput types in
<a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go" target="_blank" rel="noopener noreferrer">output.go</a>:</p><ul><li><a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go#L947" target="_blank" rel="noopener noreferrer">AliasOutput</a> and</li><li><a href="https://github.com/iotaledger/goshimmer/blob/master/packages/ledgerstate/output.go#L1840" target="_blank" rel="noopener noreferrer">ExtendedLockedOutput</a></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/iotaledger/Goshimmer/tree/develop/docOps/docs/protocol_specification/advanced_outputs.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/protocol_specification/ledgerstate"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ ledgerstate</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/protocol_specification/markers"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Markers ¬ª</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#motivation" class="table-of-contents__link">Motivation</a></li><li><a href="#functional-requirements-of-iscp" class="table-of-contents__link">Functional Requirements of ISCP</a></li><li><a href="#output-design" class="table-of-contents__link">Output Design</a><ul><li><a href="#introducing-alias-account" class="table-of-contents__link">Introducing Alias Account</a></li><li><a href="#representing-a-smart-contract-chain-account-in-ledger" class="table-of-contents__link">Representing a Smart Contract Chain Account in Ledger</a></li><li><a href="#consuming-an-alias-output" class="table-of-contents__link">Consuming an Alias Output</a></li></ul></li><li><a href="#locking-funds-into-aliases" class="table-of-contents__link">Locking Funds Into Aliases</a></li><li><a href="#extended-output" class="table-of-contents__link">Extended Output</a><ul><li><a href="#unlocking-via-aliasid" class="table-of-contents__link">Unlocking via AliasID</a></li><li><a href="#unlocking-via-fallback" class="table-of-contents__link">Unlocking via Fallback</a></li><li><a href="#timelock" class="table-of-contents__link">Timelock</a></li></ul></li><li><a href="#notes" class="table-of-contents__link">Notes</a></li><li><a href="#how-does-it-work-for-iscp" class="table-of-contents__link">How does it work for ISCP?</a></li><li><a href="#additional-use-cases" class="table-of-contents__link">Additional Use Cases</a><ul><li><a href="#delegated-keys" class="table-of-contents__link">Delegated Keys</a></li><li><a href="#non-fungible-tokens" class="table-of-contents__link">Non-Fungible Tokens</a></li></ul></li><li><a href="#goshimmer-implementation" class="table-of-contents__link">GoShimmer Implementation</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/welcome">Welcome</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQ</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tutorials/setup">Tutorials</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/implementation_design/event_driven_model">Implementation Design</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/protocol_specification">Protocol Specification</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/apis/api">API</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/tooling">Tooling</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/teamresources/release">Team Resources</a></li></ul></div><div class="col footer__col"><div class="footer__title">Articles</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/iotaledger/Goshimmer" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2021 IOTA Foundation, Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.dedbe278.js"></script>
<script src="/assets/js/main.0e69db9d.js"></script>
</body>
</html>